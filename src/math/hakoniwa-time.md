# 変更履歴

**このドキュメントが最新です**
- (Version 3.1) https://github.com/toppers/hakoniwa-px4sim/issues/340 , issue #69 箱庭時刻同期の数学的証明より移動
- (Version 3.2) https://github.com/toppers/hakoniwa-core-cpp-client/issues/69#issue-2541993494 より移動
- (Version 4.0) https://github.com/toppers/hakoniwa-paper/tree/main/robosym2025 高瀬先生により論文化される（そこからのフィードバック戻し）
- (Version 4.1) 査読結果を一部反映
- (Version 5.2) https://github.com/hakoniwalab/hakoniwa-design-docs/math/hakoniwa-time.md 複数フェデレート対応

#   概要

箱庭は、複数のシミュレータを繋いで連携動作させるシミュレーションハブである。本簡易論文では、箱庭の中心モジュールである箱庭コア（以降コア）と各シミュレータ（以降アセット）間の時刻同期の考え方を公理的に定義し、それによって、各シミュレータが独自に動作していても、全アセットがあらかじめ設定された最大許容遅延時間内で同期されていることを数学的に証明する。

さらに、行われた定式化をシミュレーション実験結果と比較し、結論の正当性を確認する。さらに、定式化とシミュレーションに基づいて、なるべく早くシミュレーションが進むようなパラメータの設定についても統計的に考察する。

# 定義

以下に、問題の置かれている環境、条件、想定、および、変数名等を定義する。

## コアとアセット

箱庭全体システムは、1つのコアと複数のアセットからなる。

- コア ( $Core$ )： 箱庭のコアであり、自分のシミュレーション時刻であるコア時刻を持ちながら全体のタクト（指揮棒）を担当する。
- アセット( $Asset$ )： 各（サードパーティ製を含む）シミュレータ。サードパーティのシミュレータは、コアとの小さな通信インターフェイスを作成することによってアセット化され、コアと通信する。アセットは、独自のシミュレーション時刻であるアセット時刻を内部に持っている。

シミュレータの特性上、実時間よりも速く進む時間を使うことで、実世界での実験よりも高速にシミュレーションを行う、といった利用法が想定される。例えば、実時間では1日かかるシミュレーションが10秒で完了する、などの利点がある。さらに、入出力に時間のかかる他のシミュレータを待ったり、デバッガで止まったシミュレータに合わせて他のシミュレータも止めるなどの利用法も考えられる。

![synch concept](sync-concept.png)

コアとアセットは、同一あるいはネットワーク接続された計算機上のソフトウェアによる実現を前提としており、それぞれの内部にシミュレーション時刻を保有している。また、両者は通信やメモリにより、自由なタイミングにて、お互いの時刻を知ることができる。コアは $1$ つ。アセットは全部で $n$ 個あり、 $1 \ldots n$ の番号が振られている。

## シミュレーション時刻とウォール時刻

実世界の時刻をウォール時刻 $t$ と呼ぶ。また、コアとアセットはそれぞれ、任意の現在ウォール時刻 $t$ で自身もしくはコアの内部シミュレーション時刻を知ることができる。ウォール時刻には、小文字の $t$ を、シミュレーション時刻には、大文字の $T$ を使うことにする。

- $t$ - ウォール時刻（実世界の時刻）。独立変数（ $\geq 0$ ）。
- $T_c(t)$ - ウォール時刻 $t$ におけるコアのシミュレーション時刻。 $t$ の従属変数（ $\geq 0$ ）。
- $T_i(t)$ - ウォール時刻 $t$ におけるアセット $i$ のシミュレーション時刻（ $i = 1 \ldots n$ ）。 $t$ の従属変数（ $\geq 0$ ）。

これらは、すべて正の実数（ $t \in \mathbb{R}, t \geq 0$ ）として以下議論するが、実際の計算機上では十分な精度を持った整数型もしくは、浮動小数点型として保持する。

さらに、シミュレーション時刻の更新（カウントアップ）について、以下の規則を設ける。

## カウントアップ

- コアおよびアセットは、それぞれ一定ウォール時間間隔で自己のシミュレーション時刻を更新する。この動作を「カウントアップ」という。
- カウントアップは、コアおよびアセット $i$ 毎にそれぞれ定義されたウォール時間間隔 $\Delta t_c, \Delta t_i (> 0)$ で行われる。
- カウントアップ時には、「他者の時刻を取得」し、「自己の時刻を修正」する。本稿の基本モデルでは、通信遅延・処理時間・計算機間の時計ずれはないと仮定し（強い仮定）、これらがある場合は別モデルとして扱う。
- 1回のカウントアップ時に更新（前回時刻への追加）されるシミュレーション時間間隔は、 コア、アセットそれぞれ、 $\Delta T_c, \Delta T_i(>0)$  （進行: progress）、もしくは $0$（停留: retain） である。

この仮定により、それぞれのシミュレーション時刻は、踊り場を持つ階段状に、一定上昇幅で広義単調増加する。

<img width="393" alt="countup" src="countup.png">

# カウントアップと規則

動機は、 $n$ 個のアセットとコアのシミュレーション時刻を、想定される範囲内で同期させることである。
具体的には、アセットはコアより早く進むことはなく、コアはアセットよりも許容時間幅を超えて早く進むことはないようにしたい。そのために、カウントアップ時には以下の規則を設ける。

コアとアセットのシミュレーション時刻ずれの許容時間間隔を、「最大許容遅延時間」 $D_{max} (>0)$ として定義する。

- $D_{max}$ - 最大許容遅延時間(Maximum Delay Tolerance)

### 初期状態の一致

$$
T_i(0) = T_c(0) = 0  \ldots 初期においてすべてのアセット i とコアのシミュレーション時刻は一致している。
$$

### アセットのカウントアップ規則

各アセット $i = 1 \ldots n$ は、以下の更新規則に従う。

ウォール時刻 $t$ において、前回シミュレーション時刻 $T_i(t - \Delta t_i)$ と現在のコアシミュレーション時刻 $T_c(t)$ から、新しいシミュレーション時刻 $T_i(t)$ を決定する。

新シミュレーション時刻 $T_i(t)$は、前シミュレーション時刻を規定幅 $\Delta T_i$ だけ進めたと想定した値（想定新時刻 $T_i'(t)$ ）が、コアの現時刻 $T_c(t)$ を追い越さないように確定する。

- カウントアップ間隔

$$
\Delta t_i \ldots ウォール時間間隔（ アセット i 毎に異なってよい）
$$

- 1 回の時刻増加幅

$$
0 もしくは \Delta T_i \ldots シミュレーション時間間隔（ i 毎に異なってよい）
$$

- 想定新時刻

$$
T_i'(t) = T_i(t - \Delta t_i) + \Delta T_i
$$

- 確定新時刻
 
$$
T_i(t)  =
\begin{cases}
T_i'(t)  & (T_i'(t)  \leq T_c(t) の時) \ldots 進行 (a.1) \\
T_i(t - \Delta t_i) & (T_i'(t) \gt T_c(t) の時) \ldots 停留 (a.2) (※note: ここで T_c(t) まで進行させる案もある)
\end{cases}
$$

- アセット時刻更新における保存則

上記ルールによって、すべてのアセット $i$ について以下の不等式が、すべてのウォール時刻 $t$ について成り立つ。

$$
T_i(t)  \leq T_c(t) \quad (\forall i) \ldots (a.3)
$$

すなわち、

$$
\max_{i = 1 \ldots n} T_i(t) \leq T_c(t) \ldots (a.4)
$$

### 証明

初期条件およびシミュレーション時刻更新ルールから、数学的帰納法による。すなわち、(a.3)および(a.4)が、

1. $t=0$ で上記条件が成り立っていることが確かめられる。
2. $N-1$ 回目カウントアップ時に成り立っていれば、 $N$ 回目カウントアップにおいても、成り立っていることが、カウントアップ規則から確かめられる。

よって、すべてのカウントアップ時において、(a.3) は維持される。また、関数 $T_i(t)$ がカウントアップ時以外の領域では定数関数であることから、(a.3) は任意の $t \geq 0$ について成り立つ。(a.4) は (a.3) の $i$ による総称を $\max$ を使った表記に書き換えたのみ。

（note: ここでは、 $\Delta t_i$ は固定長としているが、それが $t$ によって変化する場合でも、ウォール時間点列として単調増加な数列、 $t = 0, t_1, t_2, \ldots$ を取れば同様の証明ができる。）


### コアのカウントアップ規則

コアも同様に、ウォール時刻 $t$ において、前回シミュレーション時刻 $T_c(t - \Delta t_c)$ と $n$ 個のアセットシミュレーション時刻 $T_i(t) (i = 1 \ldots n)$ から、自身の新しいシミュレーション時刻 $T_c(t)$ を決定する。

新シミュレーション時刻 $T_c(t)$ は、前シミュレーション時刻を規定幅 $\Delta T_c$ だけ進めたと想定した値（想定新時刻 $T_c'(t)$ ）が、どのアセットの現時刻 $T_i(t)$ 
をも、許容幅 $D_{max}$ を超えて追い越さないように確定する。（ここで、 $D_{max}$ は $\Delta T_c, \Delta T_i$ に比べて大きい必要がある：後述のデッドロック参照）。


- カウントアップ間隔

$$
\Delta t_c \ldots  ウォール時間間隔
$$

- 1 回の時刻増加幅

$$
0 もしくは \Delta T_c \ldots  シミュレーション時間間隔
$$

カウントアップの際、新時刻値は、コアの現時刻を進めたと想定した値（想定新時刻）が、他のアセットの現時刻より **最大許容遅延時間 $D_{max}$ を超えて進んでしまわないように** 確定する。

- 想定新時刻

$$
T_c'(t) = T_c(t - \Delta t_c) + \Delta T_c
$$

- 想定最大遅延幅

$$
D'_{max} = \max_{i = 1 \ldots n}(T_c'(t) - T_i(t))
$$

- 確定新時刻

$$
T_c(t)  =
\begin{cases}
T_c'(t)  & (D'_{max}  \leq D_{max} の時) \ldots 進行 (b.1) \\
T_c(t - \Delta t_c) & (D'_{max} \gt D_{max} の時) \ldots 停留 (b.2) 
\end{cases}
$$

- コア時刻更新における保存則

上記規則によって、すべてのアセット $i$ について以下の不等式が、すべてのウォール時刻 $t$ について成り立つ。

$$
T_c(t)  \leq T_i(t) + D_{max} \quad (\forall i) \ldots (b.3)
$$

すなわち、

$$
T_c(t)  \leq \min_{i = 1 \ldots n}  T_i(t) + D_{max} \ldots (b.4)
$$

### 証明

アセットの場合と同様に、初期条件およびシミュレーション時刻更新ルールから、数学的帰納法による。すなわち、

1. $t=0$ で上記条件が成り立っていることが確かめられる。
2. $N-1$ 回目カウントアップ時に成り立っていれば、 $N$ 回目カウントアップにおいても、成り立っていることが、カウントアップ規則から確かめられる。

よって、すべてのカウントアップ時において、(b.3) は維持される。また、関数 $T_c(t)$ がカウントアップ時以外の領域では定数関数であることから、(b.3) は任意の $t \geq 0$ について成り立つ。

ここでは、 $\Delta t_i$ は固定長としているが、それが $t$ によって変化する場合でも、ウォール時間点列として単調増加な数列、 $t = 0, t_i, t_2, \ldots$ を取れば同様の証明ができる。

(b.4) は (b.3) の $i$ による総称を $\min$ を使った表記に書き換えたのみ。

<img width="1075" alt="countup zone" src="countup-zone.png">

### 終了時

シミュレーションは終了しない無限ループとして実現できる。その場合、上記条件はいかなる時刻でも成立している。
明示的な停止の際にはコアがカウントアップを止めることで行われる場合と、あるアセットがカウントアップを止めることで行われる場合がある。
どちらの場合でも、上記条件が成立したままで、シミュレーションは終了する。


# シミュレーション時刻について得られた結論

前述した2つの等式を再掲する。 これらは、 $t \geq 0$ について恒等的に成立する。

- どのアセットのシミュレーション時刻も、コアのシミュレーション時刻より進んでいない。

$$
\max_{i = 1 \ldots n} T_i(t) \leq T_c(t) \ldots (c.1)
$$

- コアのシミュレーション時刻は、どのアセットのシミュレーション時刻より、最大許容遅延時間を超えて進んでいない。

$$
T_c(t)  \leq \min_{i = 1 \ldots n}  T_i(t) + D_{max} \ldots (c.2)
$$

この2つの命題より、次の2つの重要な命題がなりたつ。これが本小論文の最初の結論である。

- コアのシミュレーション時刻は、最も進んだアセット時刻より遅れておらず、最も遅れたアセット時刻より最大許容遅延時間を超えて進んでいない。

$$
\max_{i = 1 \ldots n} T_i(t) \leq T_c(t) \leq \min_{i = 1 \ldots n}  T_i(t) + D_{max} \ldots (c.3)
$$


さらに、この不等式の中央にある $T_c(t)$ を省くことで、

- 最も進んだアセットと最も遅れたアセットのシミュレーション時刻差は、高々最大許容遅延時間である、

$$
\max_{i = 1 \ldots n} T_i(t) \leq \min_{i = 1 \ldots n}  T_i(t) + D_{max} \ldots (c.4)
$$

すなわち、アセットのペア $(i, j)$ について以下が言える。

- どんなアセットのペア $(i, j)$ を選んでも、シミュレーション時刻差は最大許容時間以内である。

$$
| T_i(t) - T_j(t) | \leq D_{max} \quad (\forall i, j) \ldots (c.5)
$$

<img width="649" alt="time distribution" src="T-distribution.png">

**これは、コアのシミュレーション時刻を調停役（タクト）にして、お互いに直接干渉し合わない別々のアセットが、最大許容遅延時間以内で調歩同期していると言える。**

### 補足
上記結論は、本文で定義した基本モデル（通信遅延・処理時間・計算機間の時計ずれを考えないモデル）の下で成立する。これらの要素を含む場合は、別モデルとして評価する必要がある。

# デッドロック回避（進行性）

ここで、時刻同期の性質を次の2つに分けて整理する。

- 安全性（safety）：
	本稿で証明した (a.4), (b.4) の不変条件（最大遅延幅を超えないこと）。
- 進行性（liveness）：
	いずれかのノードが有限時間内に時刻を前進し続け、全体が停止しないこと。

ここまでの議論で安全性は更新規則から維持される一方、カウントアップ規則のみでは進行性は保証されない。前節の
「$D_{max}$ は $\Delta T_c, \Delta T_i$ より大きい必要がある」 という注記は、進行性の観点で置いている。これを正確に議論する。アセット$i$とコアのシミュレーション時刻差（コアシミュレーション時刻に対するアセット $i$ のシミュレーション時刻の遅れ幅）を、

$$
D_i(t)=T_c(t)-T_i(t) \quad (i=1,\ldots,n)
$$

と定義する。カウントアップ規則の下で、アセットとコアの進行条件は以下である（ $D_i$ が $T_c$ と $T_i$ の関数であることに注意）。

- アセット $i$ が進行するための必要十分条件（前述の(a.1)より）：

$$
\Delta T_i \leq D_i(t) \ldots (d.1)アセットがコアを追い越さない
$$

- コアが進行するための必要十分条件（前述の(b.1)より）：

$$
D_i(t) + \Delta T_c \leq D_{max} \quad (\forall i) \ldots (d.2) どのアセットより D_{max} を超えてコアが進まない
$$

ここで $\Delta T_c, \Delta T_i > 0$ とする。

## 全停止しないための要請から導かれる条件

要請：
コアと全アセットが同時に永久停留する状態（全停止デッドロック）を許さない。

この要請は、任意の時点 $t$ で次を満たすことと同値である。

- あるアセット $i$ が (d.1) を満たして進行可能、または
- コアが (d.2) を満たして進行可能。

任意の時点で「全アセットが停留側にある局面」

$$
D_i(t) < \Delta T_i \quad (\forall i)
$$

を考える。この局面では、要請よりコアが進行可能でなければならない。すなわち (d.2)

$$
D_i(t) + \Delta T_c \leq D_{max} \quad (\forall i)
$$

が必要である。

ここで、上の局面では各 $D_i(t)$ は $\Delta T_i$ より小さい任意の値を取り得る。したがって、常に (d.2) を保証するには、$D_i(t)$ の上界である $\Delta T_i$ においても不等式が成り立つ必要がある。よって

$$
\Delta T_i + \Delta T_c \leq D_{max} \quad (\forall i) \ldots (e.1)
$$

が必要となる。これが十分条件であることも示す（すなわち、必要十分な条件）。

### 進行性（デッドロック回避）の証明（(e.1) の十分性）

以下を仮定する。

1. 設計条件 (e.1) を満たすように $\Delta T_i$ を設定する。
2. 各アセットおよびコアのカウントアップは公平に実行される（どのアセットにも有限時間内にカウントアップタイミングが回ってくる=fair scheduling）。

上記仮定 1–2 の下で、コアと全アセットが同時に永久停留するデッドロック状態は存在しないことを証明する。

証明：

もし、どのアセットも進行できないとすると、

$$
D_i(t) < \Delta T_i \quad (\forall i)
$$

が成り立つ。設計条件 (e.1) より、

$$
\Delta T_i \leq D_{max}-\Delta T_c \quad (\forall i)
$$

これと $D_i(t) < \Delta T_i$ を合わせると、

$$
D_i(t) + \Delta T_c < D_{max} \quad (\forall i)
$$

が成り立つので、(d.2)

$$
D_i(t) + \Delta T_c \leq D_{max} \quad (\forall i)
$$

が成り立ち、 **コアは進行できる**。したがって、この場合も全ノード同時停留ではない。

以上より、任意の時点で「アセットの誰か」または「コア」のどちらかは進行可能である。よって、全ノードが同時に永久停留するデッドロック状態は存在しない。

注：以上は「全停止デッドロックがない」ことの証明である。個別ノードの一時的停留は起こり得るが、仮定 2 の下で全体として進行は継続する。

# 補足
上記結論は、カウントアップ時に他者時刻を遅延なく取得できるという基本モデルの仮定の下で成立する。通信遅延・処理時間・計算機間の時計ずれを考慮する場合は、本稿の証明範囲外であり、別途遅延モデルを導入して再評価する必要がある。


# 多段拡張

コアとアセット（複数）の組みが複数あり、それらがツリー状に親子関係を有している場合に拡張する。
１つの組みは同一ノードで動くケースが多く、HLAから用語を借りてフェデレート（Federate）と呼ぶ。

<img width="649" alt="federates" src="federates.png">

フェデレート同士の時刻調停は、そのコア同士で行われる。1対の親子ペアにおいて、親のコア時刻を $T_c^{parent}$、子のコア時刻を $T_c^{child}$ と表記する。
親子関係にある２つのフェデレートのコアの同士は、上記で考察したコアとアセットの関係同様、常に $T_c^{parent}$ が $T_c^{child}$ より進んでおり、かつ $D_{max}$ 以上先に進まない状態を維持するように時刻を（強い仮定として）瞬時に交換する。

親フェデレートのコアは、自身のアセットと同様に子フェデレートを扱い、前述の時刻更新規則に従えば、次の２式が常に保たれる（ $T_i$ はアセットのシミュレーション時刻）。

$$
T_c^{child} \leq T_c^{parent} \leq T_c^{child} + D_{max} \ldots 親フェデレート内の時刻関係
$$

$$
\max_i T_i^{child} \leq T_c^{child} \leq \min_i T_i^{child} + D_{max} \ldots 子フェデレート内の時刻関係
$$

両式を左右二つに分けて、さらにそれぞれを辺々加えて、「子のコア」と「親のコア」の時刻のずれは、

$$
\max_i T_i^{child} \leq T_c^{parent} \leq \min_i T_i^{child} + 2D_{max}
$$

を得る。すなわち、

- 親コア時刻はどの子コアより時刻が進んでおり、子フェデレートのアセットの遅れは、親コア時刻から $2D_{max}$ を超えない。

また、これによって親子階層を $n$ 層にしても、先頭（最上位コア）のシミュレーション時刻と最後尾（最下位子アセット）のシミュレーション時刻は $n D_{max}$ 以内に収まる。そして、すべてのアセットはその中間の時刻となる。すなわち、

- どの階層のどのアセットのペア $(i, j)$ を選んでも、シミュレーション時刻差は最大許容時間 $D_{max}$ の $n$ （階層数）倍以内である。

$$
| T_i(t) - T_j(t) | \leq n D_{max} \quad (\forall i, j)
$$


アセット総数 $N$ 個を最上位から（ $k$ 本の枝を持つ）フェデレートで階層分散する場合、階層数は $\log_k N$となるため、最大遅延時間は、

$$
D_{max} \log_k N
$$

であり、総アセット数 $N$ に対して遅延時間 $O(\log_k N)$ で有効にスケールするモデルとなっている。
（ちなみに、子フェデレートが最後尾を使って各フェデレートが報告すれば、 全体で $D_{max}$ 内に収まる。）

# 実験結果

$10$ 個のアセットを1つのフェデレーションで動作させたときのシミュレーション結果を示す。
![](simulation-result.png)


# パラメータについての考察

パラメータの設定によって、シミュレーション時間にはトレードオフが発生する。
<img width="727" alt="tradeoff" src="tradeoff.png">

## TODO:
- ネットワーク遅延などの影響（瞬時に相手の情報が取れると強い仮定がある）
- 確率的なゆれによる遅延の影響（ゆれによって、アセットが増えると先頭アセットと末尾アセットの差が広がると予想）
- 森さんの実験結果と突合し、 $\Delta t_i, D_{max}, \Delta T_i, \Delta T_c$ などのパラメータをどのように調整すると、早くシミュレーションが進む考察する。
- コアが増えたとき、CPU 時間（Quota）の分け合いが発生した場合の考察

以上
